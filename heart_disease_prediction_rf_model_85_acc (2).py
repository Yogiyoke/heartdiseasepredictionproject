# -*- coding: utf-8 -*-
"""Heart Disease Prediction: RF Model - 85% Acc

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/heart-disease-prediction-rf-model-85-acc-8394ae1a-2c1b-489c-bcf9-3472f9c57034.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20240421/auto/storage/goog4_request%26X-Goog-Date%3D20240421T070645Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D75a13f1e417eddae7763615f079a6ad22d80afa5e4d7eaa9ef841bf5f4ad12c166ffcd2abb48a2206d9667f217f6d8d2c0ed0b5d7f624843336b8fc18fe8d8863718a90d292d6fe79b82e4421f33f211d254665d99de9fa1866ca44619ff06e998b667d9a5a78798cc73272aad43c57ba09029719c4a7ec4e4b7edb8ebe7b8fad9a31e7b850bd2d79c0471c8738f4257b59a49dbfc27a37fbc07cadc9fd8fa9e9154f81ace597a10813896cb5a50f4da674b7aeb0ce0fbfed1a4ea4be6c606b3b3bbe83163d7ba315cd0b2d3d68835de3207656ab089203cf00dee0e76d9bd6529977fe5377c9af87af92621db106615c9e8fe01cc19b3289e6409de6abc9b23
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES
# TO THE CORRECT LOCATION (/kaggle/input) IN YOUR NOTEBOOK,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.

import os
import sys
from tempfile import NamedTemporaryFile
from urllib.request import urlopen
from urllib.parse import unquote, urlparse
from urllib.error import HTTPError
from zipfile import ZipFile
import tarfile
import shutil

CHUNK_SIZE = 40960
DATA_SOURCE_MAPPING = 'heart-disease-diagnosis-dataset:https%3A%2F%2Fstorage.googleapis.com%2Fkaggle-data-sets%2F3309453%2F5780739%2Fbundle%2Farchive.zip%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com%252F20240421%252Fauto%252Fstorage%252Fgoog4_request%26X-Goog-Date%3D20240421T070645Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D6549685762299e404429a6495be79a116c0ccd1d9d27a8a1859d90c60fdace97f1139f106063fa914db64bf8b789d9de10c20ad3acd71295ba03e2f6fc6734775fbe8e8a22a951be8489241f18f2842abaf91dbc76ce9269b1384977a8fdc21c586bdaf09c8837f9cdd6d08ddf9bdb972307c329c9b664a1c873be284f2669f0f77cf68d4dad3a6ded01efceeea00b69db248e6b4a3ecf5736a75503eefe245f4a1453c16633e36d3c8fe8ac56d17fdd121fcef11f6f41d94235ba9852b559e09274023de1b2c149dd2856d181765bba28739ff5cc5e1ed5283cfde5ef23387971c2b54fb3a3f12b423cdd484a67a74d203eb3ec60809fb80fbc498408af8773'

KAGGLE_INPUT_PATH='/kaggle/input'
KAGGLE_WORKING_PATH='/kaggle/working'
KAGGLE_SYMLINK='kaggle'

!umount /kaggle/input/ 2> /dev/null
shutil.rmtree('/kaggle/input', ignore_errors=True)
os.makedirs(KAGGLE_INPUT_PATH, 0o777, exist_ok=True)
os.makedirs(KAGGLE_WORKING_PATH, 0o777, exist_ok=True)

try:
  os.symlink(KAGGLE_INPUT_PATH, os.path.join("..", 'input'), target_is_directory=True)
except FileExistsError:
  pass
try:
  os.symlink(KAGGLE_WORKING_PATH, os.path.join("..", 'working'), target_is_directory=True)
except FileExistsError:
  pass

for data_source_mapping in DATA_SOURCE_MAPPING.split(','):
    directory, download_url_encoded = data_source_mapping.split(':')
    download_url = unquote(download_url_encoded)
    filename = urlparse(download_url).path
    destination_path = os.path.join(KAGGLE_INPUT_PATH, directory)
    try:
        with urlopen(download_url) as fileres, NamedTemporaryFile() as tfile:
            total_length = fileres.headers['content-length']
            print(f'Downloading {directory}, {total_length} bytes compressed')
            dl = 0
            data = fileres.read(CHUNK_SIZE)
            while len(data) > 0:
                dl += len(data)
                tfile.write(data)
                done = int(50 * dl / int(total_length))
                sys.stdout.write(f"\r[{'=' * done}{' ' * (50-done)}] {dl} bytes downloaded")
                sys.stdout.flush()
                data = fileres.read(CHUNK_SIZE)
            if filename.endswith('.zip'):
              with ZipFile(tfile) as zfile:
                zfile.extractall(destination_path)
            else:
              with tarfile.open(tfile.name) as tarfile:
                tarfile.extractall(destination_path)
            print(f'\nDownloaded and uncompressed: {directory}')
    except HTTPError as e:
        print(f'Failed to load (likely expired) {download_url} to path {destination_path}')
        continue
    except OSError as e:
        print(f'Failed to load {download_url} to path {destination_path}')
        continue

print('Data source import complete.')

"""<h1 style="color:#159364; font-family:verdana;"> <center>ðŸ«€Heart Disease Diagnosis</center> </h1>

# DataSet Information:
The dataset you provided contains information on various attributes related to heart disease. Here is a description of each attribute:

| Attribute                          | Attribute Type | Attribute Values                       |
|------------------------------------|----------------|----------------------------------------|
| age                                | Real           |                                        |
| sex                                | Binary         | 0 = Female, 1 = Male                   |
| chest pain type                    | Nominal        | 1 = Typical angina,                    |
|                                    |                | 2 = Atypical angina,                   |
|                                    |                | 3 = Non-anginal pain,                  |
|                                    |                | 4 = Asymptomatic                       |
| resting blood pressure             | Real           |                                        |
| serum cholestoral                  | Real           |                                        |
| fasting blood sugar                | Binary         | 0 = No, 1 = Yes                        |
| resting electrocardiographic       | Nominal        | 0 = Normal,                            |
| results                            |                | 1 = Abnormality related to ST-T wave,  |
|                                    |                | 2 = Left ventricular hypertrophy       |
| max heart rate                     | Real           |                                        |
| exercise induced angina            | Binary         | 0 = No, 1 = Yes                        |
| oldpeak                            | Real           |                                        |
| ST segment                         | Ordered        | 1 = Upsloping,                         |
|                                    |                | 2 = Flat,                              |
|                                    |                | 3 = Downsloping                        |
| major vessels                      | Real           |                                        |
| thal                               | Nominal        | 3 = Normal,                            |
|                                    |                | 6 = Fixed defect,                      |
|                                    |                | 7 = Reversible defect                  |
| heart disease                      | Binary         | 1 = Absence,                           |
|                                    |                | 2 = Presence                           |

The dataset consists of a total of 270 observations, with no missing values. The goal is to predict whether a patient has heart disease based on the given attribute information. The cost matrix indicates the cost associated with misclassifying the true and predicted values, where the cost of predicting absence when the true value is absence is 0, the cost of predicting presence when the true value is presence is 0, and the cost of predicting absence when the true value is presence, or predicting presence when the true value is absence, is 5.

# ðŸ“šImporting Libraries
"""

import numpy as np
import pandas as pd

from matplotlib import pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report, roc_curve, auc, precision_recall_curve

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

"""# Data Overview"""

df= pd.read_csv('/kaggle/input/heart-disease-diagnosis-dataset/dataset_heart.csv')
df.head()

"""# ðŸ§®Summary statistics"""

df.describe().T

"""# Detecting outliers"""

def boxplots(df):
    cols = df.columns[:-1]
    n = (len(cols) - 1) // 6 + 1
    m = min(len(cols), 6)
    fig, axes = plt.subplots(nrows=n, ncols=m, figsize=(15, 10))
    for idx, col in enumerate(cols):
        i = idx // m
        j = idx % m
        sns.boxplot(data=df, x=col, ax=axes[i][j])

    plt.tight_layout()
    plt.show()

boxplots(df)

"""# Fixing outliers"""

def outliers_removal(df, i):
    perc = np.percentile(df[i], [0, 25, 50, 75, 100])
    iqr = perc[3] - perc[1]
    _min = perc[1] - 1.5*iqr
    _max = perc[3] + 1.5*iqr
    df.loc[df[i] > _max, i] = _max
    df.loc[df[i] < _min, i] = _min
    return df

for i in df.columns[:-1]:
    df = outliers_removal(df, i)

boxplots(df)

"""# ðŸŒ²Random Forest Model"""

X = df.drop('heart disease', axis=1)
y = df['heart disease']
y = y.map({1: 0, 2: 1})
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

"""# Evaluating model(Accuracy, CM, ROC Curve, Precision-Recall curve, Cross-Validation Scores)"""

accuracy = accuracy_score(y_test, y_pred)
print('Accuracy:', accuracy)

cm = confusion_matrix(y_test, y_pred)
print('Confusion Matrix:')
print(cm)

report = classification_report(y_test, y_pred)
print('Classification Report:')
print(report)

probas = model.predict_proba(X_test)
fpr, tpr, thresholds = roc_curve(y_test, probas[:, 1])
roc_auc = auc(fpr, tpr)

plt.figure()
plt.plot(fpr, tpr, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], 'k--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

precision, recall, thresholds = precision_recall_curve(y_test, probas[:, 1])

plt.figure()
plt.plot(recall, precision, label='Precision-Recall curve')
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title('Precision-Recall Curve')
plt.legend(loc="lower left")
plt.show()

cv_scores = cross_val_score(model, X, y, cv=5)
print('Cross-Validation Scores:', cv_scores)
print('Average Cross-Validation Score:', np.mean(cv_scores))

"""The results obtained from the evaluation metrics provide information about the performance of the classification model.

- Accuracy: The accuracy of the model is 0.8518, which means it correctly predicts the presence or absence of heart disease in approximately 85.18% of the cases.

- Confusion Matrix: The confusion matrix shows the number of true positive (31), true negative (15), false positive (2), and false negative (6) predictions. In this case, the model correctly predicted 31 instances of absence of heart disease and 15 instances of presence of heart disease. However, it misclassified 2 instances of absence as presence and 6 instances of presence as absence.

- Classification Report: The classification report provides metrics such as precision, recall, and F1-score for each class (1 and 2) in the dataset. Precision measures the proportion of true positive predictions out of all positive predictions, recall measures the proportion of true positive predictions out of all actual positives, and F1-score is the harmonic mean of precision and recall. The weighted average F1-score is 0.85, indicating a reasonable balance between precision and recall for both classes.
"""